<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>動画分割・合体プレイヤー</title>
    <style>
        body { font-family: sans-serif; background: #1a1a1a; color: white; text-align: center; padding: 20px; }
        
        /* 動画を表示するコンテナ */
        .split-screen {
            display: flex;
            width: 90%;
            max-width: 1000px;
            aspect-ratio: 16 / 9; /* 動画の標準比率 */
            margin: 20px auto;
            border: 4px solid #444;
            overflow: hidden;
            background: black;
        }

        /* 各動画のスタイル（左半分を表示） */
        .left-half-video {
            width: 50%; /* 画面の半分 */
            height: 100%;
            object-fit: cover; /* 領域を埋める */
            object-position: left; /* 「左半分」を表示の基準にする */
            border: none;
        }

        .right-half-video {
            width: 50%; /* 画面の半分 */
            height: 100%;
            object-fit: cover; /* 領域を埋める */
            object-position: right; /* 「右半分」を表示の基準にする */
            border: none;
        }

        /* 選択エリア */
        .controls {
            display: flex;
            justify-content: space-around;
            margin-top: 20px;
        }
        .select-box {
            background: #333;
            padding: 15px;
            border-radius: 8px;
            width: 45%;
        }
        select {
            padding: 8px;
            width: 100%;
            margin-top: 10px;
        }
        .play-btn {
            margin-top: 30px;
            padding: 15px 40px;
            font-size: 1.2em;
            cursor: pointer;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 5px;
        }
        /* YouTube split styling */
        .split-screen-youtube {
            display: flex;
            width: 90%;
            max-width: 1000px;
            aspect-ratio: 16 / 9;
            margin: 20px auto;
            border: 4px solid #444;
            overflow: hidden;
            background: black;
        }
        .yt-side { width:50%; height:100%; overflow:hidden; position:relative; }
        /* iframe を横幅 200% にして左右をトリミングして表示する */
        .yt-frame iframe {
            position: absolute !important;
            top: 0 !important;
            left: 0 !important;
            /* iframe の inline width/height を上書きして左右半分ずつ表示 */
            width: 200% !important;
            height: 100% !important;
            border: 0 !important;
            transform-origin: left top;
        }
        /* 左側はそのまま（左半分） */
        .yt-side.left .yt-frame iframe { transform: translateX(0%); }
        /* 右側は左方向へ 50% 移動（右半分を表示） */
        .yt-side.right .yt-frame iframe { transform: translateX(-50%); }
    </style>
</head>
<body>

    <h1>2つの動画を合体再生</h1>

    <div class="split-screen">
        <video id="videoA" class="left-half-video" muted playsinline>
            <source src="" type="video/mp4">
        </video>
        <video id="videoB" class="right-half-video" muted playsinline>
            <source src="" type="video/mp4">
        </video>
    </div>

    <button class="play-btn" onclick="syncPlay()">同時再生 / 一時停止</button>

    <!-- <div class="controls">
        <div class="select-box">
            <h3>左側の映像 (動画A)</h3>
            <select id="selectA" onchange="changeVideo('A')">
                <option value="">動画を選択してください</option>
            </select>
        </div>

        <div class="select-box">
            <h3>右側の映像 (動画B)</h3>
            <select id="selectB" onchange="changeVideo('B')">
                <option value="">動画を選択してください</option>
            </select>
        </div>
    </div> -->

    <!-- YouTube 用コントロール（初期は非表示） -->
    <div id="youtubeControls" class="select-box" style="display:none; margin:20px auto; max-width:1000px;">
        <h3>リストから選択</h3>
        <div style="display:flex; gap:10px;">
            <select id="ytSelectA" style="flex:1; padding:8px;"></select>
            <select id="ytSelectB" style="flex:1; padding:8px;"></select>
            <button onclick="loadYouTubeIDs()">読み込み</button>
        </div>
        <p style="margin-top:8px; font-size:0.9em; color:#ccc;">リストから左右の動画を選択してください。</p>
        <!-- リスト表示: 各項目に「左に設定」「右に設定」ボタンを表示 -->
        <div id="ytList" style="margin-top:12px; text-align:left; max-height:240px; overflow:auto; background:#222; padding:8px; border-radius:6px;"></div>
    </div>

    <!-- YouTube 分割画面（iframe をトリミングして左右半分だけ表示） -->
    <div id="youtubeSplit" class="split-screen-youtube" style="display:none;">
        <div class="yt-side left">
            <div class="yt-frame" id="ytA"></div>
        </div>
        <div class="yt-side right">
            <div class="yt-frame" id="ytB"></div>
        </div>
    </div>

    <script>
    // --- 共通 ---
    // ローカル動画は存在しない前提にするため初期は YouTube を選択状態にする
    let currentSource = 'youtube'; // 'local' or 'youtube'
        const vA = document.getElementById('videoA');
        const vB = document.getElementById('videoB');

        function toggleSource(mode) {
            currentSource = mode;
            const youtubeControls = document.getElementById('youtubeControls');
            const youtubeSplit = document.getElementById('youtubeSplit');
            const localVideos = document.querySelector('.split-screen');
            if (mode === 'youtube') {
                youtubeControls.style.display = '';
                youtubeSplit.style.display = '';
                localVideos.style.display = 'none';
            } else {
                youtubeControls.style.display = 'none';
                youtubeSplit.style.display = 'none';
                localVideos.style.display = '';
            }
        }


        document.addEventListener('DOMContentLoaded', () => {
            // 初期 UI を現在のソースに合わせる
            toggleSource(currentSource);
            // Local / YouTube のそれぞれに合わせた初期読み込み
            // if (currentSource === 'local') populateVideoSelects();
            if (currentSource === 'youtube') youtubeSelect();
        });

        function changeVideo(side) {
            // local モードでのみ動画の src を設定する（local が無効化されている場合は何もしない）
            if (currentSource !== 'local') return;
            if (side === 'A') {
                const val = document.getElementById('selectA').value;
                if (!val) { vA.pause(); vA.removeAttribute('src'); vA.load(); return; }
                vA.src = val;
                vA.load();
            } else {
                const val = document.getElementById('selectB').value;
                if (!val) { vB.pause(); vB.removeAttribute('src'); vB.load(); return; }
                vB.src = val;
                vB.load();
            }
        }

        vA.onseeked = () => { try { vB.currentTime = vA.currentTime; } catch (e) {} };
        vB.onseeked = () => { try { vA.currentTime = vB.currentTime; } catch (e) {} };

        // --- YouTube 埋め込みロジック ---
        // プレーヤー参照
        let playerA = null, playerB = null;
        let ytSyncInterval = null;
        const SYNC_THRESHOLD = 0.3; // 秒

        // YouTube IFrame API を遅延ロード
        let ytApiLoaded = false;
        function ensureYouTubeApi() {
            if (ytApiLoaded) return;
            const tag = document.createElement('script');
            tag.src = 'https://www.youtube.com/iframe_api';
            document.head.appendChild(tag);
            ytApiLoaded = true;
        }

        // API ready callback (global)
        window.onYouTubeIframeAPIReady = function() {
            // noop: プレーヤーは loadYouTubeIDs 側で作る
        };

        function createPlayersIfNeeded() {
            if (playerA && playerB) return;
            // player containers: 'ytA', 'ytB'
            playerA = new YT.Player('ytA', {
                height: '100%', width: '100%', videoId: '',
                playerVars: { rel:0, modestbranding:1 },
                events: {
                    onStateChange: onPlayerStateChangeA
                }
            });
            playerB = new YT.Player('ytB', {
                height: '100%', width: '100%', videoId: '',
                playerVars: { rel:0, modestbranding:1 },
                events: {
                    onStateChange: onPlayerStateChangeB
                }
            });
        }

        // 選択されたリスト項目から YouTube を読み込んで cue する
        function loadYouTubeIDs() {
            const selA = document.getElementById('ytSelectA');
            const selB = document.getElementById('ytSelectB');
            const idA = selA && selA.value ? selA.value.trim() : '';
            const idB = selB && selB.value ? selB.value.trim() : '';
            if (!idA || !idB) {
                alert('左右両方の動画をリストから選択してください');
                return;
            }
            ensureYouTubeApi();
            // API 読み込み後にプレーヤー作成 -> 動画を cue
            const waitCreate = () => {
                try {
                    if (typeof YT === 'undefined' || typeof YT.Player === 'undefined') {
                        setTimeout(waitCreate, 200);
                        return;
                    }
                    createPlayersIfNeeded();
                    // cueVideoById でロードして一旦停止（自動再生しない）
                    try { playerA.cueVideoById(idA); } catch(e){}
                    try { playerB.cueVideoById(idB); } catch(e){}
                } catch (e) {
                    console.error('Error creating players:', e);
                }
            };
            waitCreate();
        }

        // youtube_list.json からセレクトを作成する
        async function youtubeSelect() {
            const selA = document.getElementById('ytSelectA');
            const selB = document.getElementById('ytSelectB');
            if (!selA || !selB) return;
            try {
                const res = await fetch('videos/youtube_list.json', { cache: 'no-store' });
                if (!res.ok) throw new Error('videos/youtube_list.json not found');
                const list = await res.json();
                // Clear existing
                selA.innerHTML = '';
                selB.innerHTML = '';
                // Add placeholder
                const opt0 = document.createElement('option'); opt0.value = ''; opt0.textContent = '動画を選択してください';
                selA.appendChild(opt0.cloneNode(true));
                selB.appendChild(opt0.cloneNode(true));
                list.forEach(item => {
                    const o = document.createElement('option');
                    o.value = item.id || item.url || '';
                    o.textContent = item.name || (item.url || item.id);
                    selA.appendChild(o.cloneNode(true));
                    selB.appendChild(o.cloneNode(true));
                });
                // Also render a clickable list with assign buttons
                const listContainer = document.getElementById('ytList');
                if (listContainer) {
                    listContainer.innerHTML = '';
                    list.forEach(item => {
                        const row = document.createElement('div');
                        row.style.display = 'flex';
                        row.style.justifyContent = 'space-between';
                        row.style.alignItems = 'center';
                        row.style.padding = '6px 8px';
                        row.style.borderBottom = '1px solid rgba(255,255,255,0.04)';
                        const title = document.createElement('div');
                        title.textContent = item.name || item.id || item.url;
                        title.style.flex = '1';
                        title.style.paddingRight = '8px';
                        const btnLeft = document.createElement('button');
                        btnLeft.textContent = '左に設定';
                        btnLeft.style.marginRight = '6px';
                        btnLeft.onclick = () => assignYouTube('A', item.id || item.url || '');
                        const btnRight = document.createElement('button');
                        btnRight.textContent = '右に設定';
                        btnRight.onclick = () => assignYouTube('B', item.id || item.url || '');
                        const btnWrap = document.createElement('div');
                        btnWrap.appendChild(btnLeft);
                        btnWrap.appendChild(btnRight);
                        row.appendChild(title);
                        row.appendChild(btnWrap);
                        listContainer.appendChild(row);
                    });
                }
            } catch (err) {
                console.warn('Could not load videos/youtube_list.json:', err.message);
            }
        }

        // ボタンで左右どちらかに割り当てる（select を更新して、可能なら cue する）
        function assignYouTube(side, id) {
            if (!id) return;
            const sel = side === 'A' ? document.getElementById('ytSelectA') : document.getElementById('ytSelectB');
            if (!sel) return;
            sel.value = id;
            // 既に API が読み込まれていてプレーヤーが作られていれば片側だけ cue する
            try {
                if (typeof YT !== 'undefined' && (playerA || playerB)) {
                    if (side === 'A' && playerA && playerA.cueVideoById) playerA.cueVideoById(id);
                    if (side === 'B' && playerB && playerB.cueVideoById) playerB.cueVideoById(id);
                }
            } catch (e) {
                // ignore
            }
        }

        function onPlayerStateChangeA(event) {
            if (!playerB) return;
            if (event.data === YT.PlayerState.PAUSED) {
                try { playerB.pauseVideo(); } catch(e){}
            } else if (event.data === YT.PlayerState.PLAYING) {
                try { playerB.playVideo(); } catch(e){}
            }
        }
        function onPlayerStateChangeB(event) {
            if (!playerA) return;
            if (event.data === YT.PlayerState.PAUSED) {
                try { playerA.pauseVideo(); } catch(e){}
            } else if (event.data === YT.PlayerState.PLAYING) {
                try { playerA.playVideo(); } catch(e){}
            }
        }

        function syncPlay() {

            if (!playerA || !playerB) {
                alert('YouTube 動画が読み込まれていません。ID を読み込んでください。');
                return;
            }
            try {
                const stateA = playerA.getPlayerState();
                if (stateA !== YT.PlayerState.PLAYING) {
                    // 位置を合わせてから再生
                    const t = playerA.getCurrentTime ? playerA.getCurrentTime() : 0;
                    try { playerB.seekTo(t, true); } catch(e){}
                    // 両方再生
                    playerA.playVideo(); playerB.playVideo();

                    if (ytSyncInterval) clearInterval(ytSyncInterval);
                    ytSyncInterval = setInterval(() => {
                        try {
                            const ta = playerA.getCurrentTime();
                            const tb = playerB.getCurrentTime();
                            const diff = Math.abs(ta - tb);
                            if (diff > SYNC_THRESHOLD) {
                                playerB.seekTo(ta, true);
                            }
                        } catch(e) {}
                    }, 500);
                } else {
                    playerA.pauseVideo(); playerB.pauseVideo();
                    if (ytSyncInterval) { clearInterval(ytSyncInterval); ytSyncInterval = null; }
                }
            } catch (e) {
                console.error('syncPlay error:', e);
            }
        }
    </script>

</body>
</html>
